# âš¡ Module 02: STL Algorithms - Quick Reference

**A one-page cheat sheet for common C++ STL algorithms**

---

## ðŸ“‹ Table of Contents

1. [Non-Modifying Algorithms](#1-non-modifying-algorithms)
2. [Modifying Algorithms](#2-modifying-algorithms)
3. [Sorting Algorithms](#3-sorting-algorithms)
4. [Numeric Algorithms](#4-numeric-algorithms)
5. [Set Operations](#5-set-operations)
6. [Common Predicates](#6-common-predicates)

---

## 1. Non-Modifying Algorithms

These algorithms inspect but do not change the elements in a range.

### `find`
Finds the first element equal to a value.
```cpp
auto it = std::find(vec.begin(), vec.end(), value);
if (it != vec.end()) { /* found */ }
```
**Complexity:** O(n)

### `find_if`
Finds the first element satisfying a predicate.
```cpp
auto it = std::find_if(vec.begin(), vec.end(), [](int x){ return x > 10; });
```
**Complexity:** O(n)

### `count`
Counts occurrences of a value.
```cpp
int num_fives = std::count(vec.begin(), vec.end(), 5);
```
**Complexity:** O(n)

### `count_if`
Counts elements satisfying a predicate.
```cpp
int num_even = std::count_if(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; });
```
**Complexity:** O(n)

### `search`
Finds the first occurrence of a sub-sequence.
```cpp
auto it = std::search(vec.begin(), vec.end(), sub_vec.begin(), sub_vec.end());
```
**Complexity:** O(n*m)

### `all_of`, `any_of`, `none_of`
Checks if all, any, or no elements satisfy a predicate.
```cpp
bool all_positive = std::all_of(vec.begin(), vec.end(), [](int x){ return x > 0; });
bool any_negative = std::any_of(vec.begin(), vec.end(), [](int x){ return x < 0; });
bool none_zero = std::none_of(vec.begin(), vec.end(), [](int x){ return x == 0; });
```
**Complexity:** O(n)

### `for_each`
Applies a function to each element.
```cpp
std::for_each(vec.begin(), vec.end(), [](int x){ std::cout << x << " "; });
```
**Complexity:** O(n)

---

## 2. Modifying Algorithms

These algorithms change the elements in a range.

### `copy`
Copies elements from one range to another.
```cpp
std::vector<int> dest(vec.size());
std::copy(vec.begin(), vec.end(), dest.begin());
```
**Complexity:** O(n)

### `transform`
Applies a function to a range and stores the result.
```cpp
// Unary operation
std::transform(vec.begin(), vec.end(), dest.begin(), [](int x){ return x * 2; });

// Binary operation
std::transform(v1.begin(), v1.end(), v2.begin(), dest.begin(), std::plus<int>());
```
**Complexity:** O(n)

### `replace`
Replaces all occurrences of a value.
```cpp
std::replace(vec.begin(), vec.end(), old_value, new_value);
```
**Complexity:** O(n)

### `replace_if`
Replaces elements satisfying a predicate.
```cpp
std::replace_if(vec.begin(), vec.end(), [](int x){ return x < 0; }, 0);
```
**Complexity:** O(n)

### `remove`
Moves elements to be removed to the end of the range. **Does not change container size.**
```cpp
auto new_end = std::remove(vec.begin(), vec.end(), value);
// Use with erase to actually remove elements
vec.erase(new_end, vec.end());
```
**Complexity:** O(n)

### `remove_if`
Moves elements satisfying a predicate to the end.
```cpp
auto new_end = std::remove_if(vec.begin(), vec.end(), [](int x){ return x % 2 != 0; });
vec.erase(new_end, vec.end()); // Removes all odd numbers
```
**Complexity:** O(n)

### `fill`
Assigns a value to all elements in a range.
```cpp
std::fill(vec.begin(), vec.end(), 0);
```
**Complexity:** O(n)

### `generate`
Assigns values generated by a function to a range.
```cpp
std::generate(vec.begin(), vec.end(), [](){ return rand() % 100; });
```
**Complexity:** O(n)

---

## 3. Sorting Algorithms

### `sort`
Sorts a range.
```cpp
// Ascending
std::sort(vec.begin(), vec.end());

// Descending
std::sort(vec.begin(), vec.end(), std::greater<int>());
```
**Complexity:** O(n log n)

### `stable_sort`
Sorts a range, preserving the relative order of equal elements.
```cpp
std::stable_sort(vec.begin(), vec.end());
```
**Complexity:** O(n log n) or O(n log^2 n)

### `partial_sort`
Sorts the first `k` elements of a range.
```cpp
// Sorts the first 3 elements
std::partial_sort(vec.begin(), vec.begin() + 3, vec.end());
```
**Complexity:** O(n log k)

### `nth_element`
Places the `n`-th element in its sorted position.
```cpp
// Places the median element at its correct sorted position
std::nth_element(vec.begin(), vec.begin() + vec.size()/2, vec.end());
```
**Complexity:** O(n) on average

### `partition`
Rearranges elements so that all elements satisfying a predicate come before those that don't.
```cpp
auto partition_point = std::partition(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; });
```
**Complexity:** O(n)

### `binary_search`
Checks if a value exists in a **sorted** range.
```cpp
bool found = std::binary_search(vec.begin(), vec.end(), value);
```
**Complexity:** O(log n)

### `lower_bound` / `upper_bound`
Returns an iterator to the first element not less than / greater than a value in a **sorted** range.
```cpp
auto lb = std::lower_bound(vec.begin(), vec.end(), value);
auto ub = std::upper_bound(vec.begin(), vec.end(), value);
```
**Complexity:** O(log n)

---

## 4. Numeric Algorithms

Requires `<numeric>` header.

### `accumulate`
Computes the sum of a range.
```cpp
int sum = std::accumulate(vec.begin(), vec.end(), 0);

// With custom operation
int product = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());
```
**Complexity:** O(n)

### `inner_product`
Computes the inner product of two ranges.
```cpp
int result = std::inner_product(v1.begin(), v1.end(), v2.begin(), 0);
```
**Complexity:** O(n)

### `adjacent_difference`
Computes the differences between adjacent elements.
```cpp
std::vector<int> diffs(vec.size());
std::adjacent_difference(vec.begin(), vec.end(), diffs.begin());
```
**Complexity:** O(n)

### `iota`
Fills a range with sequentially increasing values.
```cpp
std::vector<int> v(10);
std::iota(v.begin(), v.end(), 0); // v = {0, 1, 2, ..., 9}
```
**Complexity:** O(n)

---

## 5. Set Operations

These algorithms operate on **sorted** ranges.

### `set_union`
Computes the union of two sorted ranges.
```cpp
std::vector<int> result;
std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(result));
```
**Complexity:** O(n+m)

### `set_intersection`
Computes the intersection of two sorted ranges.
```cpp
std::vector<int> result;
std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(result));
```
**Complexity:** O(n+m)

### `set_difference`
Computes the difference of two sorted ranges (elements in first but not in second).
```cpp
std::vector<int> result;
std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(result));
```
**Complexity:** O(n+m)

### `set_symmetric_difference`
Computes the symmetric difference (elements in one but not both).
```cpp
std::vector<int> result;
std::set_symmetric_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(result));
```
**Complexity:** O(n+m)

---

## 6. Common Predicates

### Lambdas
The most common way to provide predicates.
```cpp
// Unary predicate
[](int x) { return x > 5; }

// Binary predicate
[](int a, int b) { return a < b; }
```

### Standard Library Functors
Requires `<functional>` header.
```cpp
std::greater<int>()
std::less<int>()
std::plus<int>()
std::multiplies<int>()
std::logical_and<bool>()
```

### Function Pointers
```cpp
bool isEven(int n) { return n % 2 == 0; }
std::find_if(vec.begin(), vec.end(), &isEven);
```

---

## ðŸ’¡ Best Practices

- **Prefer algorithms over manual loops:** More expressive, less error-prone, often more performant.
- **Use lambdas for predicates:** Concise and clear.
- **Master the remove-erase idiom:** The standard way to remove elements.
- **Know your iterator requirements:** Not all algorithms work with all iterators.
- **Remember sorted ranges:** `binary_search` and set operations require sorted input.
- **Use `<execution>` policies (C++17) for parallelism:**
  ```cpp
  #include <execution>
  std::sort(std::execution::par, vec.begin(), vec.end());
  ```

---

*Last Updated: November 15, 2025*

